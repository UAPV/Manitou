<?php



/**
 * Skeleton subclass for representing a row from the 'command' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.6.1-dev on:
 *
 * Wed May 25 23:31:12 2011
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    propel.generator.lib.model
 */
class Command extends BaseCommand {

  /**
   * Exécute la commande en redirigeant la sortie standart et d'errreur vers
   * des fichiers temporaires afin de pouvoir surveiller leur contenu en "temps réel".
   *
   * Une fois la commande terminée, son résultat est sauvegardé en BDD et les fichiers
   * temporaires sont supprimés.
   *
   * Par défaut cette fonction est bloquante ! Par contre, si $background = true, elle
   * sera exécutée en arrière plan.
   *
   *
   *
   * @return Command    self
   */
  public function exec ($background = false)
  {
    if (! $background)
    {
      $this->setStdErrFile (tempnam ('/tmp','manitou_cmd_'));
      $this->setStdOutFile (tempnam ('/tmp','manitou_cmd_'));
      $this->setStartedAt  (time());
      $this->save();

      $command = $this->getCommand()
        .' 2> '.$this->getStdErrFile()
        .'  > '.$this->getStdOutFile();

      exec($command, $result, $returnVal);

      $this->syncTmpOutput ();
      $this->setFinishedAt (time());
      $this->setReturnCode ($returnVal);
      $this->save();

      unlink($this->getStdErrFile());
      unlink($this->getStdOutFile());
    }
    else
    {
      // Pour ne pas avoir à utiliser pcntl_fork (module PHP à installer, mémoire partagée, connexion DB
      // à réinitialiser, etc) on appelle en arrière plan une URL qui va exécuter un appel bloquant
      // de la commande. C'est une bidouille mais ça marche...
      $this->save();
      $startUrl = sfContext::getInstance()->getController()->genUrl('@command_start?id='.$this->getId(), true);
      exec ('wget "'.$startUrl."\"  > /dev/null &");
    }

    return $this;
  }

  public function isStarted ()
  {
    return ($this->getStartedAt() !== null);
  }

  public function isRunning ()
  {
    return ($this->isStarted() && ! $this->isFinished() && ! $this->isStopped());
  }

  public function isStopped ()
  {
    return ($this->getFinishedAt() === null && $this->getReturnCode() !== null);
  }

  public function isFinished ()
  {
    return ($this->getFinishedAt() !== null);
  }

  public function hasErrors ()
  {
    $code = $this->getReturnCode() ;
    
    return (($code !== null && $code !== 0) || $this->getStdErr() != '');
  }

  public function syncTmpOutput ()
  {
    if (! $this->isRunning())
      return;

    $this->setStdErr (file_get_contents ($this->getStdErrFile()));
    $this->setStdOut (file_get_contents ($this->getStdOutFile()));
  }

  public function stop ()
  {
    // TODO
  }

  /**
   * @return integer Durée en secondes
   */
  public function getDuration ()
  {
    $startedAt = strtotime ($this->getStartedAt());
    $finishedAt = ($this->getFinishedAt() === null ? time() : strtotime($this->getFinishedAt()));

    return ($finishedAt - $startedAt);
  }

  public function setArgument ($name, $value)
  {
    $this->setCommand(str_replace('%'.$name.'%', escapeshellarg ($value), $this->getCommand()));
  }


	/**
	 * Code to be run before inserting to database
	 * @param PropelPDO $con
	 * @return boolean
	 */
	public function preInsert(PropelPDO $con = null)
	{
    if (! $this->getUserId())
    {
      $this->setUserId('foobar'); // TODO  sfContext::getInstance()->getUser()...
    }
    
		return parent::preInsert($con);
	}

} // Command
